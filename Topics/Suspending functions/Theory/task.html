<h2>Suspending functions</h2>
<div class="step-text">
<p>A coroutine is a part of a program that can be suspended and resumed later. Kotlin doesn't pause a coroutine at an arbitrary point, though; it can only do that when a special <strong>suspending function</strong> is called. It keeps track of suspending functions and can run another one that was waiting for execution and then resume the original function when possible, even without switching threads at OS level. This mechanism potentially allows us to run many more coroutines than the limit of the available threads. Let's see what it exactly means to us as developers.</p><h5 id="suspend-function">Suspend function</h5><p>Let's see how it works. When you call two simple functions, they run sequentially: a thread can execute only one function at a time:</p><p><picture><img alt="sequential execution of functions" height="555" src="https://ucarecdn.com/03d42e68-b8a6-4f99-a6c4-922cb3b35759/" width="1474"/></picture></p><p>But what happens if a function becomes suspended? In this case, you can pause the execution of one function and run another one. The program will not forget about your paused function and will resume it later. This is especially useful when you need to wait for some external resource.</p><p style="text-align: center;"><picture><img alt="suspending one function and starting another" height="743" src="https://ucarecdn.com/c8b71c6d-240c-4b80-afbe-dbd8e90f9286/" width="1474"/></picture></p><h5 id="use-case-example">Use case example</h5><p>Imagine we need to run a lot of "heavy" operations like calculating the <a href="https://en.wikipedia.org/wiki/Checksum" rel="noopener noreferrer nofollow" target="_blank">checksum</a> for hundreds of files we received from the internet to make sure they aren't broken (that's what package managers or torrent clients do all the time).</p><pre><code class="language-kotlin">fun loadFile(): ByteArray {
    return ... // long operation, actual code skipped for brevity
}

fun calculateChecksum(fileData: ByteArray): String {
    return ... // another long operation, actual code skipped for brevity
}

fun main() {
    for (i in 1..10_000) {
        val fileData = loadFile()
        val checksum = calculateChecksum(fileData)
        println(checksum)
    }
}
</code></pre><p>To complete all calculations faster, we can process each file on a separate thread. However, it won't improve the performance if we have more files than the CPU cores because each core can only process one thread at a time. Moreover, if we have too many threads, we will run out of memory soon because each thread requires extra RAM just to start.</p><pre><code class="language-kotlin">fun main() {
    for (i in 1..10_000) { // depends on the machine, rarely more than that
        Thread {
            val fileData = loadFileBlocking()
            val checksum = calculateChecksum(fileData)
            println(checksum)
        }.start()
    }
}
</code></pre><p>To fix the issue, more complex thread pools and callbacks are required. With coroutines, in contrast, we can run hundreds of thousands of parallel operations and keep our code simple. Kotlin will take care of suspending (pausing) those functions that are not active at the moment.</p><pre><code class="language-kotlin">import kotlinx.coroutines.*

suspend fun loadFile(): ByteArray { // now it's a suspending function
    return ... // long operation
}

suspend fun calculateChecksum(fileData: ByteArray): String { // another suspending
    return ... // long operation
}

// 'runBlocking' and 'async' build coroutines, we'll learn about it in the next topic
//  so far you need to know that everything inside one of these builders is a coroutine
fun main() = runBlocking {
    for (i in 1..10_000) { // now we can have even more operations running concurrently
        async {            // async schedules background execution of a given coroutine
            val fileData = loadFile()
            val checksum = calculateChecksum(fileData)
            println(checksum)
        }
    }
}
</code></pre><h5 id="suspension-points">Suspension points</h5><p>As we know, Kotlin can't suspend our code at arbitrary points; it can do that (but doesn't have to) when we call a suspending function â€“ a function marked with the <code class="language-kotlin">suspend</code> keyword. Such a call is a "parking point" for a coroutine.</p><p>JetBrains IDEs will mark these calls with a special symbol on the left.</p><p><picture><source media="(max-width: 480px)" srcset="https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/480x/-/format/webp/ 1x,https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/960x/-/format/webp/ 2x,https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/1440x/-/format/webp/ 3x" type="image/webp"/><source media="(max-width: 800px)" srcset="https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/800x/-/format/webp/ 1x,https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/1600x/-/format/webp/ 2x,https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/2400x/-/format/webp/ 3x" type="image/webp"/><source srcset="https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/1100x/-/format/webp/ 1x,https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/2200x/-/format/webp/ 2x,https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/-/stretch/off/-/resize/3000x/-/format/webp/ 3x" type="image/webp"/><img alt="Suspension point marker in IDE" height="66" src="https://ucarecdn.com/e5b751dd-f3d4-413b-a974-3091ca738ce1/" width="1494"/></picture></p><p>So our last example can start multiple operations concurrently because it can suspend at the <code class="language-kotlin">loadFile</code> call in the first launched coroutine and give room for the next one. Replace the suspending <code class="language-kotlin">loadFile</code> function with a regular one and you'll notice that the code will become sequential again even though we've built a coroutine with the <code class="language-kotlin">async</code> call. That's because there is no more suspension point in the <code class="language-kotlin">async</code> coroutine, and it will not let any other coroutine start until it finishes. Coroutines need to "cooperate" to allow concurrency, and they cooperate via suspension. Cooperation is especially important for operations that do not require a lot of CPU but require a lot of waiting time for disk or networking requests (like our file loading). However, we can also use it for CPU-heavy tasks (like encoding) to introduce natural suspension points where an operation can be paused or canceled.</p><h5 id="suspend-keyword">Suspend keyword</h5><p>So which function can be marked as suspending? Any! Methods, top-level functions, extension functions, and even lambdas can be suspending. Here's the definition of the <code class="language-kotlin">async</code> function we've used:</p><pre><code class="language-kotlin">public fun &lt;T&gt; CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
)
</code></pre><p>It declares the <code class="language-kotlin">block</code> parameter as a suspending extension function, and in our example we pass a three-line lambda expression to it. Note that we don't have to explicitly declare lambda as <code class="language-kotlin">suspend</code>, nor do we need to declare its parameters or return types.</p><h5 id="suspending-function-invocation">Suspending function invocation</h5><p>Suspending functions are great! So should we make all our functions suspending and use them everywhere? Not quite. Kotlin only allows calling suspending functions either from other suspending functions or from special coroutine builders like <code class="language-kotlin">runBlocking</code> and <code class="language-kotlin">async</code> (we'll learn more about them soon). And there is a reason for that: coroutines are cheap, but they are not free, and if we create them left and right, our code will become slower and harder to debug. So it's still a developer's job to figure out where we can benefit from suspending functions. For example:</p><ul><li><p>when we wait for some slow device like networks or disks;</p></li><li><p>when a long-running operation can be potentially canceled in the middle.</p></li></ul><h5 id="conclusion">Conclusion</h5><p>For a quick recap, here are the main points you need to remember about suspending functions:</p><ul><li><p>Coroutines are much cheaper than threads, but to work concurrently, they need to cooperate.</p></li><li><p>Coroutines cooperate by pausing at suspension points and letting others work.</p></li><li><p>Each call to a suspending function is a potential suspension point.</p></li><li><p>A suspending function can only be called from another suspending function or a coroutine builder.</p></li></ul>
</div>
