<h2>Flows</h2>
<div class="step-text">
<p>To work with multiple items of the same type, Kotlin offers various <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-collection/" rel="noopener noreferrer nofollow" target="_blank">collections</a>: they store the complete set of elements that are all kept in the memory at the same time. To generate items dynamically one-by-one, we can use a <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence/" rel="noopener noreferrer nofollow" target="_blank">sequence</a> – it can save memory when we only need one item at a time. However, the sequence generator function cannot be suspending, so if getting an item takes a lot of time, it may become a problem. Getting a potentially unlimited series of items in a suspending way is a common task: for example, fetching new messages from a chat API or scanning all folders on a disk and calculating the size of each one. For these tasks, we can use <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/" rel="noopener noreferrer nofollow" target="_blank">flows</a>. Let's see how they work!</p><h5 id="flow-basics">Flow basics</h5><p>Consider the example with folders – we'll first need to define a sequence of results:</p><pre><code class="language-kotlin">val folderSizes = sequence { // sequence builder lambda begins
    for (folder in folderNames) {
        val size = calculateSize(folder) // long running operation that can block a thread
        yield(size)
    }
}</code></pre><p>Then we need to use it in the following way: <code class="language-kotlin">folderSizes.forEach { doSomethingWith(it) }</code>.</p><p>To allow this code to run a suspending function instead, we can use a very similar builder – <code class="language-kotlin">flow</code>:</p><pre><code class="language-kotlin">val folderSizes = flow { // flow builder lambda begins
    for (folder in folderNames) {
        val size = calculateSize(folder) // now it can be a suspending function
        emit(size)
    }
}</code></pre><p>Collecting data is very similar, too: <code class="language-kotlin">folderSizes.collect { doSomethingWith(it) }</code>.</p><p>A flow can also be constructed from an existing collection, which may be helpful if we already know the result (e.g., when the folder size is pre-cached) or want to have dummy values (e.g., in special cases or tests). Collection-like objects like channels, sequences, and ranges can be converted to flows, too.</p><pre><code class="language-kotlin">flowOf(1, 2, 3, 4) // flow of known values

listOf(1, 2, 3, 4).asFlow() // list converted to flow

(1..4).asFlow() // range converted to flow</code></pre><p>Just like with a sequence, the flow builder returns an object right away – it won't execute the builder's lambda until a <strong>terminal</strong> operation is called on it. <code class="language-kotlin">forEach</code> is a terminal operation for a sequence, and <code class="language-kotlin">collect</code> — a terminal operation for a <em>flow</em>: it starts the execution and runs until the last item is emitted or an exception is thrown.</p><p>Before <code class="language-kotlin">collect</code> is called, the flow object is "cold": it doesn't do any computation and can be safely passed as a parameter anywhere. That's why the flow builder is not a suspending function, while <code class="language-kotlin">collect</code> is.</p><pre><code class="language-kotlin">val numbersFlow = flowOf(1, 2, 3, 4) // create flow, the object is still cold

numbersFlow.collect { print(it) } // collect flow, it will print 1234

numbersFlow.collect { print(it) } // collect same flow, it will print 1234 again 

// can repeat as many times as needed with the same result</code></pre><h5 id="flow-transformations">Flow transformations</h5><p>Similar to sequences, we can transform an upstream flow object and get a new downstream flow object by applying <strong>intermediate</strong><em> </em>operators.</p><p>To convert each element into another one, use <code class="language-kotlin">.map</code>:</p><pre><code class="language-kotlin">val anotherFlow = flowOf(1, 2, 3, 4) // creates flow that emits 1, 2, 3 ,4
    .map { it * 2 }              // creates new flow that emits 2, 4, 6, 8</code></pre><p>To filter the elements, use <code class="language-kotlin">.filter</code>:</p><pre><code class="language-kotlin">val anotherFlow = flowOf(1, 2, 3, 4)
    .filter { it % 2 == 0 } // emits 2, 4</code></pre><p>There are other transformations available in the standard library, like <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html" rel="noopener noreferrer nofollow" target="_blank">take</a> — to limit the number of emitted items, <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html" rel="noopener noreferrer nofollow" target="_blank">zip</a> to stitch two flows together, and many more, including <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html" rel="noopener noreferrer nofollow" target="_blank">transform</a>, which allows you to write your own custom transformations.</p><pre><code class="language-kotlin">flowOf(1, 2, 3, 4)
    .transform { value -&gt;
        if (value % 2 == 0) { // Emit only even values, but twice
            emit(value)
            emit(value)
        } // Do nothing if odd
    } // emits 2, 2, 4, 4</code></pre><p>Multiple transformations can be applied on top of each other:</p><pre><code class="language-kotlin">flowOf(1, 2, 3, 4)
    .take(3)
    .filter { it &gt; 1 }
    .map { it * 2} // emits 4, 6</code></pre><h5 id="terminal-operators">Terminal operators</h5><p>There are multiple terminal operations, too. <code class="language-kotlin">collect</code> is the most generic one: it can be called with a lambda to be executed for each element or without parameters to simply let the flow run for its side effect:</p><pre><code class="language-kotlin">flow.collect { println(it) } // prints each element that flow emits

flow.collect() // makes the flow emit same elements but ignores them</code></pre><p>Moreover, we can collect data from the same flow as many times as we want, and it will run the same operations each time:</p><pre><code class="language-kotlin">folderSizes.collect { doSomethingWith(it) } // check folder sizes once
// ...
folderSizes.collect { doSomethingWith(it) } // and then check if something changes</code></pre><p>If we need to aggregate the emitted data into a collection, we can use <code class="language-kotlin">toList</code> and <code class="language-kotlin">toSet</code>. Note that these operations will not return until the last item is emitted.</p><p>To do the opposite, use <code class="language-kotlin">.single</code>. It will wait for the very first element and return it immediately.</p><p>And to combine all items into a single aggregate value, there are <code class="language-kotlin">.fold</code> and <code class="language-kotlin">.reduce</code>:</p><pre><code class="language-kotlin">flowOf(1, 2, 3, 4).reduce { a, b -&gt; a + b } // sum all and return 10</code></pre><p>All aforementioned terminal operations are suspending because the flow itself may contain suspending code that emits elements (but doesn't have to), so they have to be called from a coroutine. If you need a new coroutine only to collect data from a flow, there is a <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html" rel="noopener noreferrer nofollow" target="_blank">handy </a><code class="language-kotlin">launchIn</code><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/launch-in.html" rel="noopener noreferrer nofollow" target="_blank"> operator</a>, which launches a new coroutine in a given scope and runs <code class="language-kotlin">.collect()</code> inside.</p><pre><code class="language-kotlin">flow.launchIn(scope) // same as: scope.launch { flow.collect() }</code></pre><h5 id="conclusion">Conclusion</h5><p>A flow is an object that can generate a sequence of data by running a (potentially) suspending function. The flow object is "cold" and doesn't do anything before a terminal operation is called on it. Transformation can be applied on a flow to modify the data it emits; each transformation creates a new "cold" flow object. Terminal operations are suspending functions that trigger flow execution one or multiple times.</p>
</div>
